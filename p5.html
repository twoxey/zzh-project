<script src="https://cdn.jsdelivr.net/npm/p5@1.11.11/lib/p5.js"></script>
<script src="sentiment_data.js"></script>

<script>
    const screen_width = 800
    const screen_height = 600
    const cell_size = 10
    const row_count = screen_height / cell_size
    const col_count = screen_width / cell_size
    // 创建一个数组记录现在画面上所有格子的状态
    let cells = Array(row_count * col_count).fill(-1)

    const drops = []
    const words = [1, 3, 2, 3, 2, 1, 4, 2, 3, 2]
    let current_word_index = 0;

    function create_drop(emotion) {
        // 使用鼠标的位置生成新的水滴
        const drop = {
            x: mouseX / cell_size,
            y: mouseY / cell_size,
            emotion: emotion,
        }
        drops.push(drop)
    }

    function mousePressed() {
        // 第2行导入的sentiment_data.js文件当中有一个名为sentiment_data的数组，
        // 其中保存了根据文本文件生成的情绪数据，我们改为从这个数组当中读取数据
        const item = sentiment_data[current_word_index]

        // 数组的每一项"item"都有两个属性:"word"和"output"，其中word是这一项所对应的
        // 词语，output是另外一个数组，其中每一项是情绪识别的结果（现在每一个词语只有
        // 一个对应的结果，但未来有可能会修改代码输出多个结构）
        // 这里先读取结果中的第一项
        const output = item.output[0]

        // 结果的每一项都有两个属性:"label"和"score"，label是对应的不同情绪，score是
        // 这项结果的分数，我们这里使用label作为参数传给create_drop()来创建水滴
        create_drop(output.label)
        current_word_index += 1
    }

    function setup() {
        createCanvas(screen_width, screen_height);
    }

    function draw() {
        background(0);

        fill(255, 255, 255);
        rect(mouseX, mouseY, cell_size, cell_size)

        // 创建新的格子数据的数组，用来更新
        const new_cells = Array(row_count * col_count).fill(-1)
        let i = 0;
        for (const drop of drops) {
            // 这里使用水滴绘图的代码需要改成我们创建时使用的label，而不是之前的数字
            if (drop.emotion == "Neutral") {
                fill(255, 0, 0)
            } else if (drop.emotion == "Positive") {
                fill(255, 255, 0)
            } else if (drop.emotion == "Very Positive") {
                fill(255, 0, 255)
            } else if (drop.emotion == "Negative") {
                fill(0, 255, 255)
            } else if (drop.emotion == "Very Negative") {
                fill(0, 0, 255)
            }
            rect(drop.x * cell_size, drop.y * cell_size, cell_size, cell_size)

            // 获取水滴在格子的位置
            const cellx = cell_pos(drop.x);
            const celly = cell_pos(drop.y);
            // noFill();
            // stroke(255);
            // rect(cellx * cell_size, celly * cell_size, cell_size, cell_size)

            // 获取下方和左下，右下格子的状态
            const down = cells_get(cellx, celly + 1)
            const downl = cells_get(cellx - 1, celly + 1)
            const downr = cells_get(cellx + 1, celly + 1)

            if (down == -1) {
                // 如果下方格子空着，下落
                drop.y += 0.3
            } else if (downl == -1) {
                // 否则如果左侧格子空着，向左侧移动
                drop.x -= 0.1
            } else if (downr == -1) {
                // 否则如果有侧格子空着，向右侧移动
                drop.x += 0.1
            }

            const new_cellx = cell_pos(drop.x);
            const new_celly = cell_pos(drop.y);
            new_cells[new_celly * col_count + new_cellx] = i;

            ++i;
        }
        // 使用新的格子状态更新之前的状态
        cells = new_cells;
    }

    function cell_pos(val) {
        return Math.floor(val)
    }

    function cells_get(cellx, celly) {
        if (cellx < 0) return -2;
        if (cellx > col_count - 1) return -2;
        if (celly < 0) return -2;
        if (celly > row_count -1) return -2;
        return cells[celly * col_count + cellx];
    }
</script>